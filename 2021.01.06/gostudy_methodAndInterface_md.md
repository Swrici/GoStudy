## 6 方法
### 6.1 方法的声明
在函数声明时，在其名字之前放上一个变量，即是一个方法。**这个附加的参数会将该函数附加到这种类型上**，即相当于为这种类型定义了一个独占的方法。
```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```
附加的参数p，叫做**方法的接收器(receiver)**，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

方法的使用：
```go
p := Point{1, 2}
q := Point{4, 6}
//调用了包级别的函数
fmt.Println(Distance(p, q)) // "5", function call
//调用了p的方法
fmt.Println(p.Distance(q))  // "5", method call
```
这种`p.Distance(q)`的表达式被叫为选择器。

在go中，我们可以给任意类型定义方法。对于任意的命名类型来说，只要它的底层实现不是指针或者interface都是可以定义方法的。

例如：
```go
type Path []Point
```
在上例中 Path 就是命名类型，底层实现是指[]Poiint这个Slice。

### 6.2 基于指针对象的方法

当一个类有一个指针作为接收器的方法，那么该类的所有的方法都必须有一个指针接收器。
`注：在只用指针对象的方法时要使用（*对象）.方法`。

在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的。
例如下例：
```go
type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
```

只有类型(Point)和指向他们的指针(*Point)，才是可能会出现在接收器声明里的两种接收器。

我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：
```go
Point{1, 2}.ScaleBy(2) // compile error: can't take address of Point literal
```

在这里出现的三种情况：
1. 形参和实参类型相同，都不为指针类型，或者都为指针类型。
```go
Point{1, 2}.Distance(q) //  Point
pptr.ScaleBy(2)         // *Point
```

2. 形参是指针，实参是不为指针类型。隐式&
```go 
p.ScaleBy(2) // implicit (&p)
```
3 形参不是指针类型，实参是指针类型，
```go
pptr.ScaleBy(2)  //implicit (*pptr)
 ```
`注1：implicit:  隐性的`

`注2：在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝`

### 6.2.1 Nil接收器类型
Nil也是一个合法的接收器类型。就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。

### 6.3. 通过嵌入结构体来扩展类型
就是一个对象里包含着另一个对象。
就是一个结构体里包含着另一个结构体。

我们可以直接认为通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出。

我们可以把外结构体类型当作接收器来调用内结构体里的方法，即使外结构体里没有声明这些方法。

内嵌字段方法的寻找顺序：外结构体方法，再到第一个类型的的方法接着顺延往下。

`注：在同一级中不能存在两个同名的方法。`

### 6.4 方法值和方法表达式
方法值
```go
p := Point{1, 2}
q := Point{1, 2}
distanceFromP := p.Distance //点的前面是类型变量。方法值

//方法值的使用
distanceFromP(q)
```
方法表达式
```go
p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance   // 前面点的是类型，方法表达式
//使用
distance(p,q)
```

### 6.5 Bit数组

Go中的集合一般使用map[T]bool 的形式进行表示。T表示的是元素类型。

但是在一些特殊的方面我们可以用Bit数组来表示集合更好用。例如当集合里都是非负整数，元素很多的时候。

### 6.6 封装
一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。

Go中使用首字母大小写来进行封装，大写可导出，小写不可导出，这种限制包内成员的方式同样适用于**struct或者一个类型的方法**。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。

这种基于名字的手段使得在语言中**最小的封装单元是package**，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。

#### 6.6.1 封装的优点
1. 首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。
2. 隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。
3. 阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。


## 7 接口
### 7.1 接口约定
**接口类型是一种抽象的类型**。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，**唯一知道的就是可以通过它的方法来做什么**。

一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。

### 7.2. 接口类型
接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。

在定义新的接口中可以组合已有的接口来定义。这种方式以一个简写命名另一个接口，而不用声明它所有的方法。这种方式本称为**接口内嵌**。

### 7.3 实现接口的条件
一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。

接口指定的规则：
只要这个类型实现这个接口，即这个类型属于这个接口。

`注：T类型的值不拥有所有*T指针的方法，那这样它就可能只实现更少的接口。`

接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法也只有接口类型暴露出来的方法会被调用到：
```go
os.Stdout.Write([]byte("hello")) // OK: *os.File has Write method
os.Stdout.Close()                // OK: *os.File has Close method

var w io.Writer
w = os.Stdout
w.Write([]byte("hello")) // OK: io.Writer has Write method
w.Close()                // compile error: io.Writer lacks Close method
```
#### 7.3.1 interface{}类型
interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。
```go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]int{"one": 1}
any = new(bytes.Buffer)
```
### 7.4 flag.Value接口
一个标准的接口类型flag.Value是关于怎么帮助命令行标记定义新的符号的。

例如:
```go
var period = flag.Duration("period", 1*time.Second, "sleep period")

func main() {
	flag.Parse()
	fmt.Printf("Sleeping for %v...", *period)
	time.Sleep(*period)
	fmt.Println()
}
```

### 7.5 接口值
概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。

类型是编译期的概念；

因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符。

```go
var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = nil
```

一个接口的零值就是它的类型和值的部分都是nil。调用一个空接口值上的任意方法都会产生panic。

在`w = os.Stdout`这个语句中，这个赋值过程调用了**一个具体类型到接口类型的隐式转换**，



我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。


一个接口值可以持有**任意大的动态值**。例如，表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值`var x interface{} = time.Now()`
从概念上讲，不论接口值多大，动态值总是可以容下它。

#### 7.5.1 接口值的比较
接口值可以使用＝＝和！＝来进行比较。

两个接口值相等仅当它们**都是nil值**或者**它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等**。

因为接口值是可比较的，所以它们可以用在**map的键或者作为switch语句的操作数**。

但是，也存在在异常的状态。

如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic:

#### 7.5.2 警告：一个包含nil指针的接口不是nil接口
一个**不包含任何值的nil接口值**和一个**刚好包含nil指针的接口值是不同的**。
