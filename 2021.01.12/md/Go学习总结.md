Go圣经的组织形式：
第一章到第五章是基础部分，分别是：
- 第一章，入门
- 第二章，程序结构
- 第三章，基础数据类型
- 第四章，复杂数据类型
- 第五章，函数

---
第一章，入门
在入门这一章，主要是以具体的几个Demo来揭开笼罩在Go语言上的迷雾，给出一个零星不全面的轮廓。
具体的Demo主要是：
1. **Hello,World**：（学语言第一个要编写的程序）。
2. **命令行参数**：模拟Unix里echo命令的一个实现，获取到命令行的参数。
3. **查找重复的行**：实现读取到的信息中重复的行的次数。
4. **gif动画**：通过这个demo可以用代码画出一个gif动画。
5. **获取URL**：获得对应的网页前端展示标签及内容。
6. **获取多个URL**：获取多个网页的内容
7. **Web服务**：讲述了如何开启Web服务和获取restful风格的参数路径值。

在一开始第一章中，用了多个Demo来展示，Demo里使用到了还没学到的知识及对应的讲述，可能对刚接触的时候不太友好。但是坚持学下来，在学习的过程中同样也是对之后的章节的提前预习。

---
第二章，程序结构
程序结构是讲的各个程序里用到的各个部分的知识，通过一个一个的程序结构才能写出完整的程序。

共分成了7小节：
1. **命名**：讲所有命名都遵循的规则，以及使用驼峰式的命名。
2. **声明**：主要对实体及其属性进行定义，以及使用的规范，在第二章中主要讲变量和类型。其他声明（常量、函数等）的在其他章节。
3. **变量**：讲变量的创建（正常语法、短变量、指针、new函数）以及变量的生命周期(变量引用判断和逃逸情况)。
4. **赋值**：元组赋值（一次性赋值多个变量），赋值的规则。
5. **类型**：类似于新建一个类，包含着类型转换的内容，相同类型才能进行比较，
6. **包和文件**：包的作用，包内初始化的顺序。
7. **作用域**：作用域和生命周期的区别,各种作用域，大到包级别小到if级别，编译器查询变量的顺序。

这一章学习下来基本可以了解到go程序结构中的一些特殊用法，比如说元组赋值的交换值，循环遍历的range 简化遍历，下划线符号是逻辑上需要，实际上不需要的代替品等等。

---
第三章　基础数据类型

基础数据类型是 Go语言数据类型的四分之一，其他三者分别是复合类型、引用类型和接口类型。

在本章共分成了6小节：
1. **整数**：有无符合位，每种都有以八为基，不断翻倍到64的4种类型，rune、uintptr类型。以及go中存在的运算符，和类型的转换。
2. **浮点数**：对两种浮点数(float32、64)进行说明，精度范围和声明方法。
3. **复数**：讲述了两种复数形式（complex32、64）、复数的声明以及复数的比较
4. **布尔型**：布尔型的使用
5. **字符串**：不可改变，可以通过下标访问具体的字节，比较的形式，Unicode的简单介绍，
6. **常量**：除开一开始的定义和使用，紧接着的就是iota 常量生成器（）类似于枚举类型。还有的是无类型的常量的使用。

在这一章里，主要是学习各个类型的基本使用和需要转换类型时的转换方法，最后才是要注意的特别地方，像是iota的使用隐式的对数值进行改动，难点在这章unicode和utf-8的说明。


---
第四章　复合数据类型
复合数据类型是 Go语言数据类型的四分之一，其他三者分别是基础数据类型、引用类型和接口类型。
复合数据类型是有一个或多个简单数据类型结合形成的数据类型，不同的结合方式对应着不同的复杂数据类型。

在本章共分成了6小节：
1. **数组**：初始化，遍历和指针传递数组的注意点。
2. **Slice**：初始化，指针、长度和容量、slice只与nil比较，追加slice的append函数。
3. **Map**：make创建，delete删除、模拟set等。
4. **结构体**：定义和使用，字面值赋值和顺序赋值不能混合，比较，结构体嵌入和匿名成员。
5. **JSON**：概念、编组和解码。
6. **文本和HTML模板**：让显示更易读取。


在这一章中，学习了对各个复合类型的初始化，遍历，比较，以及学习了Json转Golang的解码函数，以及与之相反的编组。还有为了更有阅读效率的文本和HTML模板对收集到的数据的好处。

--- 
第五章 函数
函数对于复杂繁长的程序来说就是当之无愧的减负小能手，通过将不同功能的代码块封装到一个函数中，提高了代码的重用性不说，还增加了美观。好评！
在本章共分成了10小节：
1. 函数声明
2. 递归
3. 多返回值
4. 错误
5. 函数值
6. 匿名函数
7. 可变参数
8. Deferred函数
9. Panic异常
10.Recover捕获异常

通过这一章的学习，对函数的整体使用有新的了解，函数声明讲述了函数的头部组成，返回值可有可无，也可多值返回，参数值可以定量也可以不确定具体的数量。还有匿名函数对程序运行的优化。不用重复在外写完再调用，再通过Defer关键字可以保证资源的关闭，了解了Panic异常，以及Recover对异常的捕获处理。

---
第六章 方法
方法是面向对象过程中对于对象行为的一种描述，对面向对象的一种补充。

 在本章共分成了6小节：
 1. 方法声明
 2. 基于指针对象的方法
 3. 通过嵌入结构体来扩展类型
 4. 方法值和方法表达式
 5. 示例：Bit数组
 6. 封装
 
 通过这一章的学习，先是了解到了方法接收器的概念，然后类型被当作方法接收器时才有了自己的方法法。也知道了方法接收器分成了类型和指向类型的指针两种（编译器起到的匿名修改也对引用时起了很大的作用）。再来就是通过嵌入结构体来扩展类型，通过嵌入不同的结构体，调用它的属性和方法在使用时就很方便。再来就是了解到方法值和方法表达式的概念，就很神奇（语言学得少的大惊小怪），原来方法也是有值的，原来还可以通过方法来赋值，然后再调用方法值调用方法。

---
第七章 接口
接口是对行为的抽象，而Go和Java不同的是，Go中并不需要显式的去说明我继承了这个接口而是通过实现接口里的方法来说明已经继承了这个接口。而在这一章也出现了Go中的另一种类型：接口类型。
接口类型就是不暴露其内部接口和基础操作集合，只是说有了这个方法。

 在本章共分成了15小节：
 1. 接口是合约
 2. 接口类型
 3. 实现接口的条件
 4. flag.Value接口
 5. 接口值
 6. sort.Interface接口
 7. http.Handler接口
 8. error接口
 9. 示例：表达式求值
 10. 类型断言
 11. 基于类型断言识别错误类型
 12. 通过类型断言识别接口
 13. 类型分支
 14. 示例：基于标记的XML解码
 15. 补充几点


  要说实现一个接口，那必然是实现了其全部的接口方法。且再有了方法值的洗礼之后，再次看到什么什么值也不会感觉到奇怪，这里的方法值分成了两部分，一部分是动态类型，一部分是动态值。而通过类型断言，也就是跟类型转换差不多的功能，我们可以拿到新的不同的功能，比如说识别错误类型，或者是识别接口。接口的使用分成了两种情况，一是用一个接口的方法实现了这个接口具体类型之间的相似性。例如io.Reader,io.Writer。另外一种就是以类型断言为代表的，以一个接口值可以持有各种类型值的能力将这个接口值认为是这些类型的纽带。

---
第八章　Goroutines和Channels
这一章主要是和并发编程挂钩，学习了解Goroutines和Channels的特点和使用来面对并发时不会手忙脚乱。Goroutines和Channels主要实现的是“顺序通信进程”，简称CSP。

 在本章共分成了10小节：
 1. Goroutines
 2. 示例：并发的Clock服务
 3. 示例：并发的Echo服务
 4. Channels
 5. 并发的循环
 6. 示例：并发的Web爬虫
 7. 基于select的多路复用
 8. 示例：并发的字典遍历
 9. 并发的退出
 10.示例：聊天服务

在这一章的学习过程中了解到了goroutines是并发编程的执行单位，每一个go goroutines都会依托在main上独立运行，不同的goroutines之间的通信是通过Channels来进行交流，Channels有发送和接受两种状态，当一种进行了，就会等待另一种的到来，阻塞其他操作，从而也衍生出了一种类似的通知操作。通过select这个部分，可以了解到一个goroutines中可以有多个case都在等待，他们如果同时成立的时候就顺序上岗(case)，如果都没有就一直等待，只有一个就让一个上岗。并发的退出时通过一个广播的装置通过群发一个信号量，让接受信号量的大伙统统关闭，然后再自己关闭从而退出并发。

--- 
第九章　基于共享变量的并发
这就是引出锁的概念。

 在本章共分成了8小节：
 1. 竞争条件
 2. sync.Mutex互斥锁
 3. sync.RWMutex互斥锁
 4. 内存同步
 5. sync.Once初始化
 6. 竞争条件检测
 7. 示例：并发的非阻塞缓存
 8. Goroutines和线程

在这一章里，通过先描述具体案例可能导致数据丢失的问题，从而引出了并发读取并发修改可能会导致最终数据错误，从而引出了在使用数据的时候要进行前后锁定数据不让其他人使用，也就是悲观锁。然后再写了可读锁的好处，虽然程序代码前后有顺序还在缓存还没提交具体指令的顺序到cpu去顺序可能是不确定的。懒加载的概念和好处以及Goroutines调度器的执行情况轮流执行比起轮流切换上下文效率有所提高。

---
第十二章　反射
Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。

 在本章共分成了9小节：
 1. 为何需要反射？
 2. reflect.Type和reflect.Value
 3. Display递归打印
 4. 示例：编码S表达式
 5. 通过reflect.Value修改值
 6. 示例：解码S表达式
 7. 获取结构体字段标识
 8. 显示一个类型的方法集
 9. 几点忠告

通过这一章学习，先了解了为什么要使用反射，当程序运行过程中有时需要动态的获取类型或者值的时候反射就起了作用，然后就讲了reflect包里的关键的两个类型 Type和Value ，函数 reflect.TypeOf （）接受任意接口类型然后获得动态类型，同时也有函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回一个装载着其动态值的 reflect.Value. 但是reflect.Value 也可以持有一个接口值。再讲了通过reflect.Value进行修改值的过程，有两种，一种是调用其Set方法，另一种是通过指针获得其可取地址的reflect.Value进行修改值。最后讲了通过类型获得它的方法集。

总得来说，这阵子学得头发狂掉，脑袋坏掉，总算大体学完了，了解了Go的基本语法和部分特性，但是短暂的学习并不能让我能够对它有及其深入的了解，还学要后续的继续努力学习！
