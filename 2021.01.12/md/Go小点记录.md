- os.Args的第一个元素，os.Args[0], 是命令本身的名字；其它的元素则是程序启动时传给它的参数。

- 有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（译注：右边不能再有其它表达式），左边变量的数目必须和右边一致。

- 类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。
- 对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)）。只有当两个类型的底层基础类型相同时，才允许这种转型操作
- 包的作用 ：为了支持模块化、封装、单独编译和代码重用。
- 包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。
- 当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。
- Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
- Unicode字符rune类型通常用于表示一个Unicode码点。和int32可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

- 一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112171532522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nyd2ljaQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112171553455.png)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112171622360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nyd2ljaQ==,size_16,color_FFFFFF,t_70)
- 文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列，

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112173442279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nyd2ljaQ==,size_16,color_FFFFFF,t_70)
- 标准库中有四个包对字符串处理尤为重要：**bytes、strings、strconv和unicode包。**
- bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。
- strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
- strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
- unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。
- 在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。
- 如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。
- 我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。
- 多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。
- 如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。
- 为何slice不直接支持比较运算符呢？
	- 第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身。虽然有很多办法处理这种情形，但是没有一个是简单有效的。
	- 第二个原因，因为slice的元素是间接引用的，一个固定的slice值(译注：指slice本身的值，不是元素的值)在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。
- 禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。
- seen := make(map[string]bool) // a set of strings 实现了一个set。
- 结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。
- 一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。
- 但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构。
- 如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。
- 将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）
- 解码对应将JSON数据解码为Go语言的数据结构
- 
